<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>外挂记忆实验系统</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 10px 20px;
            background: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .tab.active {
            background: #1890ff;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .card h2 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-size: 14px;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #1890ff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #40a9ff;
        }
        
        .btn-success {
            background: #52c41a;
            color: white;
        }
        
        .btn-danger {
            background: #ff4d4f;
            color: white;
        }
        
        .result {
            margin-top: 15px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 13px;
        }
        
        .memory-item {
            padding: 15px;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .memory-item .trigger {
            font-weight: bold;
            color: #1890ff;
            margin-bottom: 5px;
        }
        
        .memory-item .lesson {
            color: #666;
            margin-bottom: 5px;
        }
        
        .memory-item .meta {
            font-size: 12px;
            color: #999;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        
        .stat-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #1890ff;
        }
        
        .stat-card .label {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .comparison-table th,
        .comparison-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e8e8e8;
        }
        
        .comparison-table th {
            background: #f0f0f0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>外挂记忆实验系统</h1>
            <p>最小可验证架构 - 论证外挂记忆的5个特性</p>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('task')">执行任务</button>
            <button class="tab" onclick="switchTab('memory')">记忆库</button>
            <button class="tab" onclick="switchTab('experiment')">实验对比</button>
        </div>
        
        <!-- 执行任务 -->
        <div id="task" class="tab-content active">
            <div class="card">
                <h2>执行任务</h2>
                <div class="form-group">
                    <label>任务类型</label>
                    <select id="taskType">
                        <option value="lottery">抽奖判断</option>
                        <option value="lottery_multi">抽奖判断（多积分/隐性规则）</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>输入（JSON格式）</label>
                    <textarea id="taskInput" placeholder='{"points": 50, "action": "lottery"}'></textarea>
                </div>
                <div class="form-group">
                    <label>实验组</label>
                    <select id="groupType">
                        <option value="A">A组（无记忆）</option>
                        <option value="B">B组（有记忆，无反思）</option>
                        <option value="C" selected>C组（有记忆+反思）</option>
                        <option value="D">D组（短期纠错 + 全局中期记忆池，可跨run复用）</option>
                        <option value="E">E组（两阶段自检纠错 + MemOS门控 + 验证固化，全量最强）</option>
                        <option value="F">F组（变更检测 + 候选竞争 + 自检纠错，高频变更更强）</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="executeTask()">执行任务</button>
                <div id="taskResult" class="result" style="display:none;"></div>
            </div>
            
            <div class="card" id="feedbackCard" style="display:none;">
                <h2>反馈</h2>
                <div class="form-group">
                    <label>反馈类型</label>
                    <select id="feedbackType">
                        <option value="correct">正确</option>
                        <option value="incorrect">错误</option>
                        <option value="better">更优解</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>反馈内容</label>
                    <textarea id="feedbackContent" placeholder="请输入反馈内容..."></textarea>
                </div>
                <button class="btn btn-success" onclick="submitFeedback()">提交反馈</button>
                <button class="btn btn-primary" onclick="autoJudge()">自动判断</button>
            </div>
        </div>
        
        <!-- 记忆库 -->
        <div id="memory" class="tab-content">
            <div class="card">
                <h2>外挂记忆库</h2>
                <button class="btn btn-primary" onclick="loadMemories()">刷新</button>
                <div id="memoriesList"></div>
            </div>
        </div>
        
        <!-- 实验对比 -->
        <div id="experiment" class="tab-content">
            <div class="card">
                <h2>实验统计</h2>
                <button class="btn btn-primary" onclick="loadStats()">刷新统计</button>
                <button class="btn btn-danger" style="margin-left:10px;" onclick="resetAll()">重置数据</button>
                <div id="statsContent"></div>
            </div>
            
            <div class="card">
                <h2>组间对比</h2>
                <div class="form-group" style="max-width: 320px;">
                    <label>任务类型</label>
                    <select id="experimentTaskType">
                        <option value="lottery">lottery（单 points）</option>
                        <option value="lottery_multi">lottery_multi（多积分/隐性规则）</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="compareModes()">对比（高频/低频规则变更）</button>
                <div id="comparisonContent"></div>
            </div>
            
            <div class="card">
                <h2>错误趋势</h2>
                <div class="form-group" style="max-width: 320px;">
                    <label>规则变更模式</label>
                    <select id="trendMode">
                        <option value="low">低频变更</option>
                        <option value="high">高频变更</option>
                        <option value="none">无变更</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="loadTrendChart()">查看趋势（图表）</button>
                <div id="trendContent">
                    <canvas id="trendChart" width="1100" height="360" style="max-width:100%; background:#fff; border:1px solid #eee; border-radius:6px;"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const API_BASE = 'http://localhost:8080/api';
        let currentTaskId = null;
        
        // 测试API连接
        async function testConnection() {
            try {
                const res = await fetch(`${API_BASE}/memories`);
                if (res.ok) {
                    console.log('API连接正常');
                } else {
                    console.error('API连接失败:', res.status);
                }
            } catch (error) {
                console.error('无法连接到API:', error);
                alert('无法连接到后端服务，请确保服务已启动在 http://localhost:8080');
            }
        }
        
        // 页面加载时测试连接
        window.addEventListener('load', () => {
            testConnection();
        });
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        async function executeTask() {
            const taskType = document.getElementById('taskType').value;
            const input = document.getElementById('taskInput').value;
            const groupType = document.getElementById('groupType').value;
            const useMemory = groupType !== 'A';
            
            if (!input.trim()) {
                alert('请输入任务输入');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/tasks/execute`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        task_type: taskType,
                        input: input,
                        group_type: groupType,
                        use_memory: useMemory
                    })
                });
                
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({error: '请求失败'}));
                    throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                
                if (!data || !data.task) {
                    throw new Error('响应格式错误: ' + JSON.stringify(data));
                }
                
                currentTaskId = data.task.id;
                
                document.getElementById('taskResult').style.display = 'block';
                document.getElementById('taskResult').textContent = 
                    `任务ID: ${data.task.id}\n` +
                    `输出: ${data.task.output || '无'}\n` +
                    `Token消耗: ${data.task.token_count || 0}\n` +
                    `使用的记忆: ${data.task.memory_ids || '无'}`;
                
                document.getElementById('feedbackCard').style.display = 'block';
            } catch (error) {
                alert('执行失败: ' + error.message);
                console.error('执行任务错误:', error);
            }
        }

        // 输入模板快捷：切换任务类型时给出更贴近生产的多积分示例
        document.getElementById('taskType').addEventListener('change', () => {
            const taskType = document.getElementById('taskType').value;
            const ta = document.getElementById('taskInput');
            if (!ta) return;
            if (taskType === 'lottery_multi') {
                ta.placeholder = '{"action":"lottery","points_available":60,"points_bonus":80,"points_locked":20,"points_expiring":10,"expiring_days":1,"points_penalty":5}';
            } else {
                ta.placeholder = '{"points": 50, "action": "lottery"}';
            }
        });
        
        async function submitFeedback() {
            if (!currentTaskId) {
                alert('请先执行任务');
                return;
            }
            
            const feedbackType = document.getElementById('feedbackType').value;
            const content = document.getElementById('feedbackContent').value;
            
            try {
                const res = await fetch(`${API_BASE}/tasks/feedback`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        task_id: currentTaskId,
                        feedback_type: feedbackType,
                        content: content
                    })
                });
                
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({error: '请求失败'}));
                    throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                
                if (!data || !data.feedback) {
                    throw new Error('响应格式错误: ' + JSON.stringify(data));
                }
                
                if (feedbackType === 'incorrect' && data.feedback.id) {
                    // 自动触发反思
                    await reflectAndSave(currentTaskId, data.feedback.id);
                }
                
                alert('反馈提交成功');
                loadMemories();
            } catch (error) {
                alert('提交失败: ' + error.message);
                console.error('提交反馈错误:', error);
            }
        }
        
        async function autoJudge() {
            if (!currentTaskId) {
                alert('请先执行任务');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/tasks/judge`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        task_id: currentTaskId
                    })
                });
                
                alert('自动判断完成');
                loadMemories();
            } catch (error) {
                alert('判断失败: ' + error.message);
            }
        }
        
        async function reflectAndSave(taskId, feedbackId) {
            try {
                await fetch(`${API_BASE}/tasks/reflect`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        task_id: taskId,
                        feedback_id: feedbackId
                    })
                });
            } catch (error) {
                console.error('反思失败:', error);
            }
        }
        
        async function loadMemories() {
            try {
                const res = await fetch(`${API_BASE}/memories`);
                
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({error: '请求失败'}));
                    throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                
                if (!data || !data.memories) {
                    throw new Error('响应格式错误: ' + JSON.stringify(data));
                }
                
                const list = document.getElementById('memoriesList');
                list.innerHTML = '';
                
                if (data.memories.length === 0) {
                    list.innerHTML = '<p style="color: #999; padding: 20px; text-align: center;">暂无记忆</p>';
                    return;
                }
                
                data.memories.forEach(m => {
                    const item = document.createElement('div');
                    item.className = 'memory-item';
                    item.innerHTML = `
                        <div class="trigger">触发: ${m.trigger || '无'}</div>
                        <div class="lesson">经验: ${m.lesson || '无'}</div>
                        <div class="meta">
                            置信度: ${m.confidence || 0} | 
                            版本: ${m.version || 1} | 
                            使用次数: ${m.use_count || 0} |
                            适用范围: ${m.apply_to || '通用'}
                        </div>
                    `;
                    list.appendChild(item);
                });
            } catch (error) {
                alert('加载失败: ' + error.message);
                console.error('加载记忆错误:', error);
            }
        }
        
        async function loadStats() {
            try {
                const res = await fetch(`${API_BASE}/experiments/stats`);
                
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({error: '请求失败'}));
                    throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                
                if (!data || !data.stats) {
                    throw new Error('响应格式错误: ' + JSON.stringify(data));
                }
                
                const content = document.getElementById('statsContent');
                const stats = data.stats;
                content.innerHTML = `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="value">${stats.total || 0}</div>
                            <div class="label">总任务数</div>
                        </div>
                        <div class="stat-card">
                            <div class="value">${stats.correct || 0}</div>
                            <div class="label">正确</div>
                        </div>
                        <div class="stat-card">
                            <div class="value">${stats.incorrect || 0}</div>
                            <div class="label">错误</div>
                        </div>
                        <div class="stat-card">
                            <div class="value">${((stats.error_rate || 0) * 100).toFixed(1)}%</div>
                            <div class="label">错误率</div>
                        </div>
                        <div class="stat-card">
                            <div class="value">${stats.avg_tokens || 0}</div>
                            <div class="label">平均Token</div>
                        </div>
                    </div>
                `;
            } catch (error) {
                alert('加载失败: ' + error.message);
                console.error('加载统计错误:', error);
            }
        }

        async function resetAll() {
            if (!confirm('确认要重置吗？将清空 tasks/feedbacks/memories/experiment_runs 等全部数据')) {
                return;
            }
            try {
                const res = await fetch(`${API_BASE}/experiments/reset`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({})
                });
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({error: '请求失败'}));
                    throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                alert('已重置');
                document.getElementById('statsContent').innerHTML = '';
                document.getElementById('comparisonContent').innerHTML = '';
            } catch (error) {
                alert('重置失败: ' + error.message);
            }
        }
        
        function renderLineChart(canvas, labels, seriesMap, options = {}) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            const padding = 45;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            const colors = options.colors || {
                A: '#ff4d4f',
                B: '#faad14',
                C: '#52c41a',
                D: '#1890ff',
                E: '#722ed1',
                F: '#13c2c2'
            };

            // axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, h - padding);
            ctx.lineTo(w - padding, h - padding);
            ctx.stroke();

            // y ticks 0..1
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            for (let i = 0; i <= 5; i++) {
                const y = padding + (plotH * i) / 5;
                const v = (1 - i / 5).toFixed(1);
                ctx.fillText(v, 10, y + 4);
                ctx.strokeStyle = '#f0f0f0';
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(w - padding, y);
                ctx.stroke();
            }

            const len = labels.length;
            function xAt(i) {
                if (len <= 1) return padding;
                return padding + (plotW * i) / (len - 1);
            }
            function yAt(v) {
                const vv = Math.max(0, Math.min(1, v));
                return padding + (1 - vv) * plotH;
            }

            // draw series
            Object.keys(seriesMap).forEach(key => {
                const arr = seriesMap[key] || [];
                ctx.strokeStyle = colors[key] || '#1890ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < len; i++) {
                    const v = arr[i] ?? arr[arr.length - 1] ?? 0;
                    const x = xAt(i);
                    const y = yAt(v);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            });

            // legend
            let lx = w - padding - 220;
            let ly = padding - 25;
            ctx.fillStyle = '#333';
            ctx.font = '13px sans-serif';
            ctx.fillText(options.title || '', padding, 20);

            Object.keys(seriesMap).forEach((key, idx) => {
                const x = lx + idx * 70;
                const y = ly;
                ctx.fillStyle = colors[key] || '#1890ff';
                ctx.fillRect(x, y, 12, 3);
                ctx.fillStyle = '#333';
                ctx.fillText(key + '组', x + 16, y + 5);
            });
        }

        function renderBarChart(canvas, labels, values, options = {}) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            const padding = 45;
            const plotW = w - padding * 2;
            const plotH = h - padding * 2;

            // axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, h - padding);
            ctx.lineTo(w - padding, h - padding);
            ctx.stroke();

            // y ticks (0..max)
            const maxV = Math.max(1, ...(values || [0]));
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            for (let i = 0; i <= 4; i++) {
                const y = padding + (plotH * i) / 4;
                const v = Math.round(maxV * (1 - i / 4));
                ctx.fillText(String(v), 10, y + 4);
                ctx.strokeStyle = '#f0f0f0';
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(w - padding, y);
                ctx.stroke();
            }

            const n = labels.length;
            if (n === 0) return;
            const barW = Math.max(2, plotW / n * 0.7);
            const gap = plotW / n;
            const color = options.color || '#1890ff';
            const markers = Array.isArray(options.markers) ? options.markers : [];
            const markerLabel = options.markerLabel || '规则变更';
            const markerThresholds = Array.isArray(options.markerThresholds) ? options.markerThresholds : [];

            function xAt(i) {
                return padding + i * gap + (gap - barW) / 2;
            }
            function yAt(v) {
                const vv = Math.max(0, v);
                return padding + (1 - vv / maxV) * plotH;
            }

            ctx.fillStyle = color;
            for (let i = 0; i < n; i++) {
                const v = values[i] ?? 0;
                const x = xAt(i);
                const y = yAt(v);
                const bh = (h - padding) - y;
                ctx.fillRect(x, y, barW, bh);
            }

            // markers: draw vertical lines at rule change points
            if (markers.length > 0) {
                ctx.strokeStyle = options.markerColor || '#ff4d4f';
                ctx.lineWidth = 2;
                ctx.fillStyle = options.markerTextColor || '#ff4d4f';
                ctx.font = '12px sans-serif';
                markers.forEach((cp) => {
                    if (cp == null) return;
                    const i = Number(cp);
                    if (!Number.isFinite(i) || i < 0 || i >= n) return;
                    const x = xAt(i) + barW / 2;
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, h - padding);
                    ctx.stroke();

                    const th = markerThresholds[i];
                    const text = th ? `${markerLabel}→${th}` : markerLabel;
                    ctx.fillText(text, Math.min(x + 4, w - padding - 140), padding + 14);
                });
            }

            ctx.fillStyle = '#333';
            ctx.font = '13px sans-serif';
            ctx.fillText(options.title || '', padding, 20);
        }

        function renderModeBlock(modeLabel, modeData) {
            if (!modeData) {
                return `<p style="color:#999;">${modeLabel}：暂无数据（请先跑一轮该模式实验）</p>`;
            }
            const overall = modeData.overall || {};
            const rounds = modeData.rounds || 0;
            const curves = modeData.curves || {};
            const trial = modeData.trial_and_error || {};
            const firstErr = modeData.first_error_round || {};
            const memStart = modeData.memory_change_start_round ?? -1;
            const memChanges = modeData.memory_changes_per_round || [];
            const labels = Array.from({length: rounds}, (_, i) => i + 1);

            // 后端 GroupStats 字段：n/correct/incorrect/error_rate
            const tableRows = ['n','correct','incorrect','error_rate'].map(k => {
                const label = {n:'总任务', correct:'正确', incorrect:'错误', error_rate:'错误率'}[k];
                const A = overall.A?.[k] ?? 0;
                const B = overall.B?.[k] ?? 0;
                const C = overall.C?.[k] ?? 0;
                const D = overall.D?.[k] ?? 0;
                const E = overall.E?.[k] ?? 0;
                const F = overall.F?.[k] ?? 0;
                const fmt = v => k === 'error_rate' ? ((v||0)*100).toFixed(1)+'%' : v;
                return `<tr><td>${label}</td><td>${fmt(A)}</td><td>${fmt(B)}</td><td>${fmt(C)}</td><td>${fmt(D)}</td><td>${fmt(E)}</td><td>${fmt(F)}</td></tr>`;
            }).join('');

            const trialText = (trial.change_points && trial.change_points.length)
                ? `变更点: ${trial.change_points.join(', ')} | 试错次数: ${trial.attempts.join(', ')} | 平均: ${Number(trial.avg_attempts||0).toFixed(2)} | 最大: ${trial.max_attempts||0}`
                : '无变更点或暂无数据';

            const chartId = `chart_${modeData.rule_mode}`;
            const barId = `bar_${modeData.rule_mode}`;
            setTimeout(() => {
                const canvas = document.getElementById(chartId);
                const series = {
                    A: curves.A?.cumulative_accuracy || [],
                    B: curves.B?.cumulative_accuracy || [],
                    C: curves.C?.cumulative_accuracy || [],
                    D: curves.D?.cumulative_accuracy || [],
                    E: curves.E?.cumulative_accuracy || [],
                    F: curves.F?.cumulative_accuracy || []
                };
                renderLineChart(canvas, labels, series, {title: `${modeLabel}：累计正确率（随轮次）`});

                const bar = document.getElementById(barId);
                renderBarChart(bar, labels, memChanges, {
                    title: `${modeLabel}：C组记忆变更柱状图（每轮判错次数）`,
                    color: '#722ed1',
                    markers: trial.change_points || [],
                    markerLabel: '规则变更',
                    markerThresholds: modeData.thresholds || []
                });
            }, 0);

            const fe = g => (firstErr[g] ?? -1) >= 0 ? `第 ${firstErr[g] + 1} 轮` : '无错误';
            const memStartText = memStart >= 0 ? `第 ${memStart + 1} 轮` : '未触发';

            return `
                <div style="margin-top:10px;">
                    <div style="color:#666; margin:6px 0;">run_id: ${modeData.run_id || '-'}</div>
                    <div style="color:#333; margin:6px 0;">
                        <b>首次出错轮次</b>：A组 ${fe('A')}｜B组 ${fe('B')}｜C组 ${fe('C')}｜D组 ${fe('D')}｜E组 ${fe('E')}｜F组 ${fe('F')}
                        <span style="margin-left:12px;"><b>记忆开始变更</b>：${memStartText}</span>
                    </div>
                    <table class="comparison-table">
                        <tr><th>指标</th><th>A组</th><th>B组</th><th>C组</th><th>D组</th><th>E组</th><th>F组</th></tr>
                        ${tableRows}
                    </table>
                    <div style="margin:10px 0; color:#333;"><b>C组调整记忆试错次数</b>: ${trialText}</div>
                    <canvas id="${chartId}" width="1100" height="320" style="max-width:100%; background:#fff; border:1px solid #eee; border-radius:6px;"></canvas>
                    <canvas id="${barId}" width="1100" height="260" style="max-width:100%; background:#fff; border:1px solid #eee; border-radius:6px; margin-top:10px;"></canvas>
                </div>
            `;
        }

        async function compareModes() {
            try {
                const taskType = document.getElementById('experimentTaskType')?.value || 'lottery';
                const res = await fetch(`${API_BASE}/experiments/compare-modes?task_type=${encodeURIComponent(taskType)}`);
                
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({error: '请求失败'}));
                    throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                
                if (!data || !data.modes) {
                    throw new Error('响应格式错误: ' + JSON.stringify(data));
                }
                
                const content = document.getElementById('comparisonContent');
                const low = data.modes.low;
                const high = data.modes.high;
                content.innerHTML =
                    `<h3 style="margin-top:0;">低频变更</h3>` +
                    renderModeBlock('低频变更', low) +
                    `<hr style="border:none;border-top:1px solid #eee; margin:18px 0;">` +
                    `<h3 style="margin-top:0;">高频变更</h3>` +
                    renderModeBlock('高频变更', high);
            } catch (error) {
                alert('对比失败: ' + error.message);
                console.error('对比组错误:', error);
            }
        }
        
        async function loadTrendChart() {
            try {
                const mode = document.getElementById('trendMode').value;
                const taskType = document.getElementById('experimentTaskType')?.value || 'lottery';
                const res = await fetch(`${API_BASE}/experiments/trend?mode=${encodeURIComponent(mode)}&task_type=${encodeURIComponent(taskType)}`);
                
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({error: '请求失败'}));
                    throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                
                if (!data || !data.curves) {
                    throw new Error('响应格式错误: ' + JSON.stringify(data));
                }
                
                const rounds = data.rounds || 0;
                const labels = Array.from({length: rounds}, (_, i) => i + 1);
                const canvas = document.getElementById('trendChart');
                const series = {
                    A: data.curves.A?.cumulative_error || [],
                    B: data.curves.B?.cumulative_error || [],
                    C: data.curves.C?.cumulative_error || [],
                    D: data.curves.D?.cumulative_error || [],
                    E: data.curves.E?.cumulative_error || [],
                    F: data.curves.F?.cumulative_error || []
                };
                renderLineChart(canvas, labels, series, {title: `${mode}：累计错误率（随轮次）`});
            } catch (error) {
                alert('加载失败: ' + error.message);
                console.error('加载趋势错误:', error);
            }
        }
    </script>
</body>
</html>

